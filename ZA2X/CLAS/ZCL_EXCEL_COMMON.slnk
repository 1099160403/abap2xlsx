<?xml version="1.0" encoding="utf-16"?>
<CLAS CLSNAME="ZCL_EXCEL_COMMON" VERSION="1" LANGU="E" DESCRIPT="Static common methods" UUID="E750494D16947660E1000000C0A8FA28" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="FEMIA" CREATEDON="20100710" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="702" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
 <publicSection>class ZCL_EXCEL_COMMON definition
  public
  final
  create public .

public section.
*&quot;* public components of class ZCL_EXCEL_COMMON
*&quot;* do not include other source files here!!!

  constants C_EXCEL_BASELINE_DATE type D value &apos;19000101&apos;. &quot;#EC NOTEXT
  class-data C_EXCEL_NUMFMT_OFFSET type INT1 value 164. &quot;#EC NOTEXT .
  constants C_EXCEL_SHEET_MAX_COL type INT4 value 16384. &quot;#EC NOTEXT
  constants C_EXCEL_SHEET_MIN_COL type INT4 value 1. &quot;#EC NOTEXT
  class-data C_SPRAS_EN type SPRAS value &apos;E&apos;. &quot;#EC NOTEXT .
  class-data O_CONV type ref to CL_ABAP_CONV_OUT_CE .
  constants C_EXCEL_1900_LEAP_YEAR type D value &apos;19000228&apos;. &quot;#EC NOTEXT

  class-methods CONVERT_COLUMN2ALPHA
    importing
      !IP_COLUMN type SIMPLE
    returning
      value(EP_COLUMN) type ZEXCEL_CELL_COLUMN_ALPHA
    raising
      ZCX_EXCEL .
  class-methods CONVERT_COLUMN2INT
    importing
      !IP_COLUMN type SIMPLE
    returning
      value(EP_COLUMN) type ZEXCEL_CELL_COLUMN
    raising
      ZCX_EXCEL .
  class-methods CONVERT_COLUMNROW2COLUMN_A_ROW
    importing
      !I_COLUMNROW type STRING
    exporting
      !E_COLUMN type ZEXCEL_CELL_COLUMN_ALPHA
      !E_ROW type ZEXCEL_CELL_ROW .
  class-methods CONVERT_RANGE2COLUMN_A_ROW
    importing
      !I_RANGE type STRING
    exporting
      !E_COLUMN_START type ZEXCEL_CELL_COLUMN_ALPHA
      !E_COLUMN_END type ZEXCEL_CELL_COLUMN_ALPHA
      !E_ROW_START type ZEXCEL_CELL_ROW
      !E_ROW_END type ZEXCEL_CELL_ROW
      !E_SHEET type ZEXCEL_SHEET_TITLE .
  class-methods DATE_TO_EXCEL_STRING
    importing
      !IP_VALUE type D
    returning
      value(EP_VALUE) type ZEXCEL_CELL_VALUE .
  class-methods ENCRYPT_PASSWORD
    importing
      !I_PWD type ZEXCEL_AES_PASSWORD
    returning
      value(R_ENCRYPTED_PWD) type ZEXCEL_AES_PASSWORD .
  class-methods ESCAPE_STRING
    importing
      !IP_VALUE type STRING
    returning
      value(EP_ESCAPED_VALUE) type STRING .
  class-methods EXCEL_STRING_TO_DATE
    importing
      !IP_VALUE type ZEXCEL_CELL_VALUE
    returning
      value(EP_VALUE) type D
    raising
      ZCX_EXCEL .
  class-methods EXCEL_STRING_TO_TIME
    importing
      !IP_VALUE type ZEXCEL_CELL_VALUE
    returning
      value(EP_VALUE) type T
    raising
      ZCX_EXCEL .
  class-methods GET_FIELDCATALOG
    importing
      !IP_TABLE type STANDARD TABLE
    returning
      value(EP_FIELDCATALOG) type ZEXCEL_T_FIELDCATALOG .
  class-methods NUMBER_TO_EXCEL_STRING
    importing
      value(IP_VALUE) type NUMERIC
    returning
      value(EP_VALUE) type ZEXCEL_CELL_VALUE .
  class-methods RECURSIVE_CLASS_TO_STRUCT
    importing
      !I_SOURCE type ANY
    changing
      !E_TARGET type DATA
      !E_TARGETX type DATA .
  class-methods RECURSIVE_STRUCT_TO_CLASS
    importing
      !I_SOURCE type DATA
      !I_SOURCEX type DATA
    changing
      !E_TARGET type ANY .
  class-methods TIME_TO_EXCEL_STRING
    importing
      !IP_VALUE type T
    returning
      value(EP_VALUE) type ZEXCEL_CELL_VALUE .</publicSection>
 <protectedSection>*&quot;* protected components of class ZCL_EXCEL_COMMON
*&quot;* do not include other source files here!!!
protected section.</protectedSection>
 <privateSection>private section.
*&quot;* private components of class ZCL_EXCEL_COMMON
*&quot;* do not include other source files here!!!

  class-data C_EXCEL_COL_MODULE type INT2 value 64. &quot;#EC NOTEXT .

  class-methods CHAR2HEX
    importing
      !I_CHAR type CHAR1
    returning
      value(R_HEX) type ZEXCEL_PWD_HASH .
  class-methods SHL01
    importing
      !I_PWD_HASH type ZEXCEL_PWD_HASH
    returning
      value(R_PWD_HASH) type ZEXCEL_PWD_HASH .
  class-methods SHR14
    importing
      !I_PWD_HASH type ZEXCEL_PWD_HASH
    returning
      value(R_PWD_HASH) type ZEXCEL_PWD_HASH .</privateSection>
 <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
 <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
 <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
 <localTestClasses>CLASS lcl_excel_common_test DEFINITION DEFERRED.
CLASS zcl_excel_common DEFINITION LOCAL FRIENDS lcl_excel_common_test.

*----------------------------------------------------------------------*
*       CLASS lcl_Excel_Common_Test DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_excel_common_test DEFINITION FOR TESTING
  DURATION SHORT
  RISK LEVEL HARMLESS
.
*?ï»¿&lt;asx:abap xmlns:asx=&quot;http://www.sap.com/abapxml&quot; version=&quot;1.0&quot;&gt;
*?&lt;asx:values&gt;
*?&lt;TESTCLASS_OPTIONS&gt;
*?&lt;TEST_CLASS&gt;lcl_Excel_Common_Test
*?&lt;/TEST_CLASS&gt;
*?&lt;TEST_MEMBER&gt;f_Cut
*?&lt;/TEST_MEMBER&gt;
*?&lt;OBJECT_UNDER_TEST&gt;ZCL_EXCEL_COMMON
*?&lt;/OBJECT_UNDER_TEST&gt;
*?&lt;OBJECT_IS_LOCAL/&gt;
*?&lt;GENERATE_FIXTURE&gt;X
*?&lt;/GENERATE_FIXTURE&gt;
*?&lt;GENERATE_CLASS_FIXTURE&gt;X
*?&lt;/GENERATE_CLASS_FIXTURE&gt;
*?&lt;GENERATE_INVOCATION&gt;X
*?&lt;/GENERATE_INVOCATION&gt;
*?&lt;GENERATE_ASSERT_EQUAL&gt;X
*?&lt;/GENERATE_ASSERT_EQUAL&gt;
*?&lt;/TESTCLASS_OPTIONS&gt;
*?&lt;/asx:values&gt;
*?&lt;/asx:abap&gt;
  PRIVATE SECTION.
* ================
    DATA:
      lx_excel  TYPE REF TO zcx_excel,
      f_cut     TYPE REF TO zcl_excel_common.  &quot;class under test

    CLASS-METHODS: class_setup.
    CLASS-METHODS: class_teardown.
    METHODS: setup.
    METHODS: teardown.
*    METHODS: char2hex FOR TESTING.
    METHODS: convert_column2alpha FOR TESTING.
    METHODS: convert_column2int FOR TESTING.
    METHODS: date_to_excel_string FOR TESTING.
    METHODS: encrypt_password FOR TESTING.
    METHODS: excel_string_to_date FOR TESTING.
    METHODS: excel_string_to_time FOR TESTING.
*    METHODS: number_to_excel_string FOR TESTING.
    METHODS: time_to_excel_string FOR TESTING.
ENDCLASS.       &quot;lcl_Excel_Common_Test


*----------------------------------------------------------------------*
*       CLASS lcl_Excel_Common_Test IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_excel_common_test IMPLEMENTATION.
* ===========================================

  METHOD class_setup.
* ===================


  ENDMETHOD.       &quot;class_Setup


  METHOD class_teardown.
* ======================


  ENDMETHOD.       &quot;class_Teardown


  METHOD setup.
* =============

    CREATE OBJECT f_cut.
  ENDMETHOD.       &quot;setup


  METHOD teardown.
* ================


  ENDMETHOD.       &quot;teardown


  METHOD convert_column2alpha.
* ============================
    DATA ep_column TYPE zexcel_cell_column_alpha.

* Test 1. Simple test
    TRY.
        ep_column = zcl_excel_common=&gt;convert_column2alpha( 1 ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_column
          exp   = &apos;A&apos;
          msg   = &apos;Wrong column conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 2. Max column for OXML #16,384 = XFD
    TRY.
        ep_column = zcl_excel_common=&gt;convert_column2alpha( 16384 ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_column
          exp   = &apos;XFD&apos;
          msg   = &apos;Wrong column conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 3. Index 0 is out of bounds
    TRY.
        ep_column = zcl_excel_common=&gt;convert_column2alpha( 0 ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_column
          exp   = &apos;A&apos;
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;assert_equals(
          act   = lx_excel-&gt;error
          exp   = &apos;Index out of bounds&apos;
          msg   = &apos;Colum index 0 is out of bounds, min column index is 1&apos;
          level = if_aunit_constants=&gt;fatal
        ).
    ENDTRY.

* Test 4. Exception should be thrown index out of bounds
    TRY.
        ep_column = zcl_excel_common=&gt;convert_column2alpha( 16385 ).

        cl_abap_unit_assert=&gt;assert_differs(
          act   = ep_column
          exp   = &apos;XFE&apos;
          msg   = &apos;Colum index 16385 is out of bounds, max column index is 16384&apos;
          level = if_aunit_constants=&gt;fatal
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;assert_equals(
          act   = lx_excel-&gt;error
          exp   = &apos;Index out of bounds&apos;
          msg   = &apos;Wrong exception is thrown&apos;
          level = if_aunit_constants=&gt;tolerable
        ).
    ENDTRY.
  ENDMETHOD.       &quot;convert_Column2alpha


  METHOD convert_column2int.
* ==========================
    DATA ep_column TYPE zexcel_cell_column.

* Test 1. Basic test
    TRY.
        ep_column = zcl_excel_common=&gt;convert_column2int( &apos;A&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_column
          exp   = 1
          msg   = &apos;Wrong column conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 2. Max column
    TRY.
        ep_column = zcl_excel_common=&gt;convert_column2int( &apos;XFD&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_column
          exp   = 16384
          msg   = &apos;Wrong column conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 3. Out of bounds
    TRY.
        ep_column = zcl_excel_common=&gt;convert_column2int( &apos;&apos; ).

        cl_abap_unit_assert=&gt;assert_differs(
          act   = ep_column
          exp   = &apos;0&apos;
          msg   = &apos;Wrong column conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;assert_equals(
          act   = lx_excel-&gt;error
          exp   = &apos;Unable to interpret column&apos;
          msg   = &apos;Colum name should be a valid string&apos;
          level = if_aunit_constants=&gt;fatal
        ).
    ENDTRY.

* Test 4. Out of bounds
    TRY.
        ep_column = zcl_excel_common=&gt;convert_column2int( &apos;XFE&apos; ).

        cl_abap_unit_assert=&gt;assert_differs(
          act   = ep_column
          exp   = 16385
          msg   = &apos;Wrong column conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;assert_equals(
          act   = lx_excel-&gt;error
          exp   = &apos;Index out of bounds&apos;
          msg   = &apos;Colum XFE is out of range&apos;
          level = if_aunit_constants=&gt;fatal
        ).
    ENDTRY.
  ENDMETHOD.       &quot;convert_Column2int


  METHOD date_to_excel_string.
* ============================
    DATA ep_value TYPE zexcel_cell_value.

* Test 1. Basic conversion
    TRY.
        ep_value = zcl_excel_common=&gt;date_to_excel_string( &apos;19000101&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
              act   = ep_value
              exp   = 1
              msg   = &apos;Wrong date conversion&apos;
              level = if_aunit_constants=&gt;critical
            ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.
* Check around the &quot;Excel Leap Year&quot; 1900
    TRY.
        ep_value = zcl_excel_common=&gt;date_to_excel_string( &apos;19000228&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
              act   = ep_value
              exp   = 59
              msg   = &apos;Wrong date conversion&apos;
              level = if_aunit_constants=&gt;critical
            ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.
    TRY.
        ep_value = zcl_excel_common=&gt;date_to_excel_string( &apos;19000301&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
              act   = ep_value
              exp   = 61
              msg   = &apos;Wrong date conversion&apos;
              level = if_aunit_constants=&gt;critical
            ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.


* Test 2. Basic conversion
    TRY.
        ep_value = zcl_excel_common=&gt;date_to_excel_string( &apos;99991212&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
              act   = ep_value
              exp   = 2958446
              msg   = &apos;Wrong date conversion&apos;
              level = if_aunit_constants=&gt;critical
            ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 3. Initial date
    TRY.
        DATA: lv_date TYPE d.
        ep_value = zcl_excel_common=&gt;date_to_excel_string( lv_date ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_value
          exp   = &apos;-693596&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 2. Basic conversion
    TRY.
        DATA exp_value TYPE zexcel_cell_value VALUE 0.
        ep_value = zcl_excel_common=&gt;date_to_excel_string( &apos;18991231&apos; ).

        cl_abap_unit_assert=&gt;assert_differs(
              act   = ep_value
              exp   = exp_value
              msg   = &apos;Wrong date conversion&apos;
              level = if_aunit_constants=&gt;critical
            ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;assert_equals(
          act   = lx_excel-&gt;error
          exp   = &apos;Index out of bounds&apos;
          msg   = &apos;Dates prior of 1900 are not available in excel&apos;
          level = if_aunit_constants=&gt;critical
        ).
    ENDTRY.

  ENDMETHOD.       &quot;date_To_Excel_String


  METHOD encrypt_password.
* ========================
    DATA lv_encrypted_pwd TYPE zexcel_aes_password.

    TRY.
        lv_encrypted_pwd = zcl_excel_common=&gt;encrypt_password( &apos;test&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
              act   = lv_encrypted_pwd
              exp   = &apos;CBEB&apos;
              msg   = &apos;Wrong password encryption&apos;
              level = if_aunit_constants=&gt;critical
            ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.
  ENDMETHOD.       &quot;encrypt_Password


  METHOD excel_string_to_date.
* ============================
    DATA ep_value TYPE d.


* Test 1. Simple test -&gt; ABAP Manage also date prior of 1900
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_date( &apos;0&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_value
          exp   = &apos;18991231&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;tolerable
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.
* Check around the &quot;Excel Leap Year&quot; 1900
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_date( &apos;59&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
              act   = ep_value
              exp   = &apos;19000228&apos;
              msg   = &apos;Wrong date conversion&apos;
              level = if_aunit_constants=&gt;critical
            ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_date( &apos;61&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
              act   = ep_value
              exp   = &apos;19000301&apos;
              msg   = &apos;Wrong date conversion&apos;
              level = if_aunit_constants=&gt;critical
            ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 2. Simple test
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_date( &apos;1&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_value
          exp   = &apos;19000101&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 3. Index 0 is out of bounds
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_date( &apos;2958446&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_value
          exp   = &apos;99991212&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 4. Exception should be thrown index out of bounds
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_date( &apos;2958447&apos; ).

        cl_abap_unit_assert=&gt;assert_differs(
          act   = ep_value
          exp   = &apos;99991212&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;fatal
        ).

        cl_abap_unit_assert=&gt;assert_differs(
          act   = ep_value
          exp   = &apos;00000000&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;fatal
        ).

      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;assert_equals(
          act   = lx_excel-&gt;error
          exp   = &apos;Index out of bounds&apos;
          msg   = &apos;Wrong exception is thrown&apos;
          level = if_aunit_constants=&gt;tolerable
        ).
    ENDTRY.
  ENDMETHOD.       &quot;excel_String_To_Date


  METHOD excel_string_to_time.
* ============================
    DATA ep_value TYPE t.

* Test 1. Simple test
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_time( &apos;0&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_value
          exp   = &apos;000000&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;tolerable
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 2. Simple test
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_time( &apos;1&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_value
          exp   = &apos;000000&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 3. Simple test
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_time( &apos;0.99999&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_value
          exp   = &apos;235959&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 4. Also string greater than 1 should be managed
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_time( &apos;4.1&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_value
          exp   = &apos;022400&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 4. string is not a number
    TRY.
        ep_value = zcl_excel_common=&gt;excel_string_to_time( &apos;NaN&apos; ).

        cl_abap_unit_assert=&gt;assert_differs(
          act   = ep_value
          exp   = &apos;000000&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;assert_equals(
          act   = lx_excel-&gt;error
          exp   = &apos;Unable to interpret time&apos;
          msg   = &apos;Time should be a valid string&apos;
          level = if_aunit_constants=&gt;fatal
        ).
    ENDTRY.
  ENDMETHOD.       &quot;excel_String_To_Time


  METHOD time_to_excel_string.
* ============================
    DATA ep_value TYPE zexcel_cell_value.

* Test 1. Basic conversion
    TRY.
        ep_value = zcl_excel_common=&gt;time_to_excel_string( &apos;000001&apos; ).
        &quot; A test directly in Excel returns the value 0.0000115740740740741000
        cl_abap_unit_assert=&gt;assert_equals(
              act   = ep_value
              exp   = &apos;0.0000115740740741&apos;
              msg   = &apos;Wrong date conversion&apos;
              level = if_aunit_constants=&gt;critical
            ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 2. Basic conversion
    TRY.
        ep_value = zcl_excel_common=&gt;time_to_excel_string( &apos;235959&apos; ).
        &quot; A test directly in Excel returns the value 0.9999884259259260000000
        cl_abap_unit_assert=&gt;assert_equals(
              act   = ep_value
              exp   = &apos;0.9999884259259260&apos;
              msg   = &apos;Wrong date conversion&apos;
              level = if_aunit_constants=&gt;critical
            ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 3. Initial date
    TRY.
        ep_value = zcl_excel_common=&gt;time_to_excel_string( &apos;000000&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
          act   = ep_value
          exp   = &apos;0&apos;
          msg   = &apos;Wrong date conversion&apos;
          level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

* Test 2. Basic conversion
    TRY.
        ep_value = zcl_excel_common=&gt;time_to_excel_string( &apos;022400&apos; ).

        cl_abap_unit_assert=&gt;assert_equals(
              act   = ep_value
              exp   = &apos;0.1000000000000000&apos;
              msg   = &apos;Wrong date conversion&apos;
              level = if_aunit_constants=&gt;critical
        ).
      CATCH zcx_excel INTO lx_excel.
        cl_abap_unit_assert=&gt;fail(
            msg    = &apos;unexpected exception&apos;
            level  = if_aunit_constants=&gt;critical    &quot; Error Severity
        ).
    ENDTRY.

  ENDMETHOD.       &quot;time_To_Excel_String




ENDCLASS.       &quot;lcl_Excel_Common_Test</localTestClasses>
 <attribute CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="C_EXCEL_1900_LEAP_YEAR" VERSION="1" LANGU="E" DESCRIPT="Excel baseline date" EXPOSURE="2" STATE="1" EDITORDER="8 " AUTHOR="DEVELOPER" CREATEDON="20120317" CHANGEDON="00000000" ATTDECLTYP="2" ATTVALUE="&apos;19000228&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="D" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="702" TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="C_EXCEL_BASELINE_DATE" VERSION="1" LANGU="E" DESCRIPT="Excel baseline date" EXPOSURE="2" STATE="1" EDITORDER="1 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" ATTDECLTYP="2" ATTVALUE="&apos;19000101&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="D" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="702" TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="C_EXCEL_COL_MODULE" VERSION="1" LANGU="E" DESCRIPT="2 byte integer (signed)" EXPOSURE="0" STATE="1" EDITORDER="2 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" ATTDECLTYP="1" ATTVALUE="64" ATTEXPVIRT="0" TYPTYPE="1" TYPE="INT2" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="702" TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="C_EXCEL_NUMFMT_OFFSET" VERSION="1" LANGU="E" DESCRIPT="2 byte integer (signed)" EXPOSURE="2" STATE="1" EDITORDER="3 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" ATTDECLTYP="1" ATTVALUE="164" ATTEXPVIRT="0" TYPTYPE="1" TYPE="INT1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="702" TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="C_EXCEL_SHEET_MAX_COL" VERSION="1" LANGU="E" DESCRIPT="2 byte integer (signed)" EXPOSURE="2" STATE="1" EDITORDER="4 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" ATTDECLTYP="2" ATTVALUE="16384" ATTEXPVIRT="0" TYPTYPE="1" TYPE="INT4" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="702" TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="C_EXCEL_SHEET_MIN_COL" VERSION="1" LANGU="E" DESCRIPT="2 byte integer (signed)" EXPOSURE="2" STATE="1" EDITORDER="5 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" ATTDECLTYP="2" ATTVALUE="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="INT4" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="702" TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="C_SPRAS_EN" VERSION="1" LANGU="E" DESCRIPT="Language Key" EXPOSURE="2" STATE="1" EDITORDER="6 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" ATTDECLTYP="1" ATTVALUE="&apos;E&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SPRAS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="702" TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="O_CONV" VERSION="1" LANGU="E" DESCRIPT="Code Page and Endian Conversion (System Format -&gt; External)" EXPOSURE="2" STATE="1" EDITORDER="7 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="CL_ABAP_CONV_OUT_CE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="702" TYPESRC_LENG="0 "/>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CHAR2HEX" VERSION="1" LANGU="E" DESCRIPT="Character to Hexadecimal" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CHAR2HEX" SCONAME="I_CHAR" VERSION="1" LANGU="E" DESCRIPT="Single-Character Indicator" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR1"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CHAR2HEX" SCONAME="R_HEX" VERSION="1" LANGU="E" DESCRIPT="Password hash" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEXCEL_PWD_HASH"/>
  <source>method CHAR2HEX.

  IF o_conv IS NOT BOUND.
    o_conv = cl_abap_conv_out_ce=&gt;create( endian   = &apos;L&apos;
                                          ignore_cerr = abap_true
                                          replacement = &apos;#&apos; ).
  ENDIF.

  CALL METHOD o_conv-&gt;reset( ).
  CALL METHOD o_conv-&gt;write( data = i_char ).
  r_hex+1 = o_conv-&gt;get_buffer( ). &quot; x&apos;65&apos; must be x&apos;0065&apos;

endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMN2ALPHA" VERSION="1" LANGU="E" DESCRIPT="Convert column indicator to Alpha" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMN2ALPHA" SCONAME="IP_COLUMN" VERSION="1" LANGU="E" DESCRIPT="Cell Column" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SIMPLE"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMN2ALPHA" SCONAME="EP_COLUMN" VERSION="1" LANGU="E" DESCRIPT="Cell Column" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEXCEL_CELL_COLUMN_ALPHA"/>
  <exception CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMN2ALPHA" SCONAME="ZCX_EXCEL" VERSION="1" LANGU="E" DESCRIPT="Exceptions for ABAP2XLSX" MTDTYPE="0" EDITORDER="1 " AUTHOR="DEVELOPER" CREATEDON="20120317" CHANGEDBY="DEVELOPER" CHANGEDON="20120317"/>
  <source>method CONVERT_COLUMN2ALPHA.

  DATA: lo_conv      TYPE REF TO cl_abap_conv_in_ce,
        lv_uccpi     TYPE i,
        lv_text      TYPE sychar02,
        lv_module    TYPE int4,
        lv_column    TYPE zexcel_cell_column.
* Propagate zcx_excel if error occurs           &quot; issue #155 - less restrictive typing for ip_column
  lv_column = convert_column2int( ip_column ).  &quot; issue #155 - less restrictive typing for ip_column
  IF lv_column GT 16384 OR lv_column LT 1.
    RAISE EXCEPTION TYPE zcx_excel
      EXPORTING
        error = &apos;Index out of bounds&apos;.
  ENDIF.
  WHILE lv_column GT 0.
    lv_module = ( lv_column - 1 ) MOD 26.
    lv_uccpi  = 65 + lv_module.

    lv_column = ( lv_column - lv_module ) / 26.

    lv_text   = cl_abap_conv_in_ce=&gt;uccpi( lv_uccpi ).
    CONCATENATE lv_text ep_column INTO ep_column.
  ENDWHILE.

endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMN2INT" VERSION="1" LANGU="E" DESCRIPT="Convert column indicator to Integer" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMN2INT" SCONAME="IP_COLUMN" VERSION="1" LANGU="E" DESCRIPT="Cell Column" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SIMPLE"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMN2INT" SCONAME="EP_COLUMN" VERSION="1" LANGU="E" DESCRIPT="Cell Column" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEXCEL_CELL_COLUMN"/>
  <exception CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMN2INT" SCONAME="ZCX_EXCEL" VERSION="1" LANGU="E" DESCRIPT="Exceptions for ABAP2XLSX" MTDTYPE="0" EDITORDER="1 " AUTHOR="DEVELOPER" CREATEDON="20120317" CHANGEDBY="DEVELOPER" CHANGEDON="20120317"/>
  <source>method CONVERT_COLUMN2INT.

  DATA: lv_uccpi     TYPE i,
        lv_factor    TYPE i,
        lv_offset    TYPE i,
        lv_char      TYPE c,
        lv_column    TYPE zexcel_cell_column_alpha,
        lv_column_c  TYPE char10,
        mod          TYPE i.
* If a number gets passed, just convert it to an integer,
* Otherwise try to interpret it as if ZEXCEL_CELL_COLUMN_ALPHA was passed
* if both fails raise exception

  lv_column_c = ip_column.
  TRANSLATE lv_column TO UPPER CASE.
  CONDENSE lv_column_c NO-GAPS.
  IF lv_column_c EQ &apos;&apos;.
    RAISE EXCEPTION TYPE zcx_excel
      EXPORTING
        error = &apos;Unable to interpret column&apos;.
  ENDIF.

* First try - convert to number
  TRY.
      IF lv_column_c CO &apos;1234567890 &apos;.                      &quot; Fix #164
        ep_column = lv_column_c.                            &quot; Fix #164
        EXIT.
      ENDIF.
    CATCH cx_sy_conversion_no_number.
      &quot; Too bad - try the character-approach
  ENDTRY.

* Upper case
  lv_column = lv_column_c.

** Get string lenght and align to right
*  lv_offset = 3 - STRLEN( lv_column ).
*
*  SHIFT lv_column RIGHT BY lv_offset PLACES.
*
** Calculate column position
*  DO 3 TIMES.
*    lv_offset = sy-index - 1.
*    lv_char = lv_column+lv_offset(1).
*    if lv_char IS INITIAL.
*      CONTINUE.
*    ENDIF.
*    lv_uccpi   = cl_abap_conv_out_ce=&gt;uccpi( lv_char ).
*    lv_factor  = 26 ** ( 3 - sy-index ).
*    ep_column  = ep_column + ( lv_uccpi MOD zcl_excel_common=&gt;c_excel_col_module ) * lv_factor.
*  ENDDO.

* Raise error if unexpected character turns up
  mod = cl_abap_conv_out_ce=&gt;uccpi( lv_column+0(1) ) MOD zcl_excel_common=&gt;c_excel_col_module.
  IF mod &lt; 1 OR mod &gt; 26.
    RAISE EXCEPTION TYPE zcx_excel
      EXPORTING
        error = &apos;Unable to interpret column&apos;.
  ENDIF.
  ep_column = mod.

  CHECK lv_column+1(1) IS NOT INITIAL.  &quot; No need to continue if string ended
  mod = cl_abap_conv_out_ce=&gt;uccpi( lv_column+1(1) ) MOD zcl_excel_common=&gt;c_excel_col_module.
  IF mod &lt; 1 OR mod &gt; 26.
    RAISE EXCEPTION TYPE zcx_excel
      EXPORTING
        error = &apos;Unable to interpret column&apos;.
  ENDIF.
  ep_column = 26 * ep_column + mod.

  CHECK lv_column+2(1) IS NOT INITIAL.  &quot; No need to continue if string ended
  mod = cl_abap_conv_out_ce=&gt;uccpi( lv_column+2(1) ) MOD zcl_excel_common=&gt;c_excel_col_module.
  IF mod &lt; 1 OR mod &gt; 26.
    RAISE EXCEPTION TYPE zcx_excel
      EXPORTING
        error = &apos;Unable to interpret column&apos;.
  ENDIF.
  ep_column = 26 * ep_column + mod.

  IF ep_column GT 16384 OR ep_column LT 1.
    RAISE EXCEPTION TYPE zcx_excel
      EXPORTING
        error = &apos;Index out of bounds&apos;.
  ENDIF.

endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMNROW2COLUMN_A_ROW" VERSION="1" LANGU="E" DESCRIPT="Convert ColumnRow i.e. AB34 to AB and 34" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMNROW2COLUMN_A_ROW" SCONAME="I_COLUMNROW" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMNROW2COLUMN_A_ROW" SCONAME="E_COLUMN" VERSION="1" LANGU="E" DESCRIPT="Cell Column" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_CELL_COLUMN_ALPHA"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_COLUMNROW2COLUMN_A_ROW" SCONAME="E_ROW" VERSION="1" LANGU="E" DESCRIPT="Natural number" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_CELL_ROW"/>
  <source>method CONVERT_COLUMNROW2COLUMN_A_ROW.
  DATA: width TYPE i,
        col_width TYPE i,
        row_str   TYPE string,
        col_str   TYPE string.
  width = strlen( i_columnrow ).
  col_width = width.
  col_str = i_columnrow.
  WHILE col_str CA &apos;0123456789&apos;.
    col_width = col_width - 1.
    col_str = i_columnrow(col_width).
  ENDWHILE.
  e_column = col_str.
  width = width - col_width.
  row_str = i_columnrow+col_width(width).
  e_row = row_str.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_RANGE2COLUMN_A_ROW" VERSION="1" LANGU="E" DESCRIPT="Converts Sheet1!AB34:CD56 to Sheet1, AB, 34, CD, 56" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120109" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_RANGE2COLUMN_A_ROW" SCONAME="I_RANGE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120109" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_RANGE2COLUMN_A_ROW" SCONAME="E_COLUMN_START" VERSION="1" LANGU="E" DESCRIPT="Cell Column Start" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120109" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_CELL_COLUMN_ALPHA"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_RANGE2COLUMN_A_ROW" SCONAME="E_COLUMN_END" VERSION="1" LANGU="E" DESCRIPT="Cell Column End" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120109" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_CELL_COLUMN_ALPHA"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_RANGE2COLUMN_A_ROW" SCONAME="E_ROW_START" VERSION="1" LANGU="E" DESCRIPT="Cell Row" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120109" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_CELL_ROW"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_RANGE2COLUMN_A_ROW" SCONAME="E_ROW_END" VERSION="1" LANGU="E" DESCRIPT="Cell Row" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120109" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_CELL_ROW"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="CONVERT_RANGE2COLUMN_A_ROW" SCONAME="E_SHEET" VERSION="1" LANGU="E" DESCRIPT="Title" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120109" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_SHEET_TITLE"/>
  <source>method CONVERT_RANGE2COLUMN_A_ROW.
  DATA:
    sheet           TYPE string,
    range           TYPE string,
    columnrow_start TYPE string,
    columnrow_end   TYPE string.

  IF i_range IS INITIAL
    OR NOT i_range CS &apos;:&apos;.
    RETURN.
  ENDIF.

  IF i_range CS &apos;!&apos;.
    SPLIT i_range AT &apos;!&apos; INTO sheet range.
    e_sheet = sheet.
  ELSE.
    range = i_range.
  ENDIF.

  REPLACE ALL OCCURRENCES OF &apos;$&apos; IN range WITH &apos;&apos;.
  SPLIT range AT &apos;:&apos; INTO columnrow_start columnrow_end.

  convert_columnrow2column_a_row(
    EXPORTING
      i_columnrow = columnrow_start
    IMPORTING
      e_column    = e_column_start
      e_row       = e_row_start
  ).
  convert_columnrow2column_a_row(
    EXPORTING
      i_columnrow = columnrow_end
    IMPORTING
      e_column    = e_column_end
      e_row       = e_row_end
  ).
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="DATE_TO_EXCEL_STRING" VERSION="1" LANGU="E" DESCRIPT="Convert date from SAP format to Excel" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="DATE_TO_EXCEL_STRING" SCONAME="IP_VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="D"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="DATE_TO_EXCEL_STRING" SCONAME="EP_VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEXCEL_CELL_VALUE"/>
  <source>METHOD date_to_excel_string.
  DATA: lv_date_diff         TYPE i.

  &quot;CHECK ip_value IS NOT INITIAL.
  &quot; Needed hack caused by the problem that:
  &quot; Excel 2000 incorrectly assumes that the year 1900 is a leap year
  &quot; http://support.microsoft.com/kb/214326/en-us
  IF ip_value &gt; c_excel_1900_leap_year.
    lv_date_diff = ip_value - c_excel_baseline_date + 2.
  ELSE.
    lv_date_diff = ip_value - c_excel_baseline_date + 1.
  ENDIF.
  ep_value = zcl_excel_common=&gt;number_to_excel_string( ip_value = lv_date_diff ).
ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="ENCRYPT_PASSWORD" VERSION="1" LANGU="E" DESCRIPT="Encrypt password" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="ENCRYPT_PASSWORD" SCONAME="I_PWD" VERSION="1" LANGU="E" DESCRIPT="AES Password" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_AES_PASSWORD"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="ENCRYPT_PASSWORD" SCONAME="R_ENCRYPTED_PWD" VERSION="1" LANGU="E" DESCRIPT="AES Password" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEXCEL_AES_PASSWORD"/>
  <source>method ENCRYPT_PASSWORD.

  DATA lv_curr_offset            TYPE i.
  DATA lv_curr_char              TYPE c LENGTH 1.
  DATA lv_curr_hex               TYPE zexcel_pwd_hash.
  DATA lv_pwd_len                TYPE zexcel_pwd_hash.
  DATA lv_pwd_hash               TYPE zexcel_pwd_hash.

  CONSTANTS:
    lv_0x7fff                    TYPE zexcel_pwd_hash VALUE &apos;7FFF&apos;,
    lv_0x0001                    TYPE zexcel_pwd_hash VALUE &apos;0001&apos;,
    lv_0xce4b                    TYPE zexcel_pwd_hash VALUE &apos;CE4B&apos;.

  DATA lv_pwd            TYPE zexcel_aes_password.

  lv_pwd = i_pwd(15).

  lv_pwd_len = STRLEN( lv_pwd ).
  lv_curr_offset = lv_pwd_len - 1.

  WHILE lv_curr_offset GE 0.

    lv_curr_char = lv_pwd+lv_curr_offset(1).
    lv_curr_hex = char2hex( lv_curr_char ).

    lv_pwd_hash = (  shr14( lv_pwd_hash ) BIT-AND lv_0x0001 ) BIT-OR ( shl01( lv_pwd_hash ) BIT-AND lv_0x7fff ).

    lv_pwd_hash = lv_pwd_hash BIT-XOR lv_curr_hex.
    SUBTRACT 1 FROM lv_curr_offset.
  ENDWHILE.

  lv_pwd_hash = (  shr14( lv_pwd_hash ) BIT-AND lv_0x0001 ) BIT-OR ( shl01( lv_pwd_hash ) BIT-AND lv_0x7fff ).
  lv_pwd_hash = lv_pwd_hash BIT-XOR lv_0xce4b.
  lv_pwd_hash = lv_pwd_hash BIT-XOR lv_pwd_len.

  WRITE lv_pwd_hash TO r_encrypted_pwd.

endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="ESCAPE_STRING" VERSION="1" LANGU="E" DESCRIPT="Escape a string" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="ESCAPE_STRING" SCONAME="IP_VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="ESCAPE_STRING" SCONAME="EP_ESCAPED_VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method ESCAPE_STRING.
  DATA lv_value TYPE string.

  lv_value = ip_value.

  REPLACE ALL OCCURRENCES OF `&apos;` IN lv_value WITH `&apos;&apos;`.

  IF lv_value CP &apos;* *&apos;.
    CONCATENATE `&apos;` lv_value `&apos;` INTO lv_value .
  ENDIF.

  ep_escaped_value = lv_value.

endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="EXCEL_STRING_TO_DATE" VERSION="1" LANGU="E" DESCRIPT="Convert date from Excel format to SAP" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="EXCEL_STRING_TO_DATE" SCONAME="IP_VALUE" VERSION="1" LANGU="E" DESCRIPT="Cell Value" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_CELL_VALUE"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="EXCEL_STRING_TO_DATE" SCONAME="EP_VALUE" VERSION="1" LANGU="E" DESCRIPT="Date" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="D"/>
  <exception CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="EXCEL_STRING_TO_DATE" SCONAME="ZCX_EXCEL" VERSION="1" LANGU="E" DESCRIPT="Exceptions for ABAP2XLSX" MTDTYPE="0" EDITORDER="1 " AUTHOR="DEVELOPER" CREATEDON="20120317" CHANGEDBY="DEVELOPER" CHANGEDON="20120317"/>
  <source>METHOD excel_string_to_date.
  DATA: lv_date_int TYPE i.

  TRY.
      lv_date_int = ip_value.
      ep_value = lv_date_int + c_excel_baseline_date - 2.
      &quot; Needed hack caused by the problem that:
      &quot; Excel 2000 incorrectly assumes that the year 1900 is a leap year
      &quot; http://support.microsoft.com/kb/214326/en-us
      IF ep_value &lt; c_excel_1900_leap_year.
        ep_value = ep_value + 1.
      ENDIF.
    CATCH cx_sy_conversion_error.
      RAISE EXCEPTION TYPE zcx_excel
        EXPORTING
          error = &apos;Index out of bounds&apos;.
  ENDTRY.
ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="EXCEL_STRING_TO_TIME" VERSION="1" LANGU="E" DESCRIPT="Convert time from Excel format to SAP" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="EXCEL_STRING_TO_TIME" SCONAME="IP_VALUE" VERSION="1" LANGU="E" DESCRIPT="Cell Value" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_CELL_VALUE"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="EXCEL_STRING_TO_TIME" SCONAME="EP_VALUE" VERSION="1" LANGU="E" DESCRIPT="Time" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="T"/>
  <exception CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="EXCEL_STRING_TO_TIME" SCONAME="ZCX_EXCEL" VERSION="1" LANGU="E" DESCRIPT="Exceptions for ABAP2XLSX" MTDTYPE="0" EDITORDER="1 " AUTHOR="DEVELOPER" CREATEDON="20120317" CHANGEDBY="DEVELOPER" CHANGEDON="20120317"/>
  <source>method EXCEL_STRING_TO_TIME.
  DATA: lv_seconds_in_day TYPE i,
        lv_day_fraction   TYPE f,
        lc_seconds_in_day TYPE i VALUE 86400.

  TRY.

      lv_day_fraction = ip_value.
      lv_seconds_in_day = lv_day_fraction * lc_seconds_in_day.

      ep_value = lv_seconds_in_day.

    CATCH cx_sy_conversion_error.
      RAISE EXCEPTION TYPE zcx_excel
      EXPORTING
        error = &apos;Unable to interpret time&apos;.
  ENDTRY.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="GET_FIELDCATALOG" VERSION="1" LANGU="E" DESCRIPT="Creates field catalog for BIND_TABLE based on internal table" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="GET_FIELDCATALOG" SCONAME="IP_TABLE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STANDARD TABLE"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="GET_FIELDCATALOG" SCONAME="EP_FIELDCATALOG" VERSION="1" LANGU="E" DESCRIPT="Table binding field catalog" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEXCEL_T_FIELDCATALOG"/>
  <source>method GET_FIELDCATALOG.

  DATA: lr_data             TYPE REF TO data,
        lo_structdescr      TYPE REF TO cl_abap_structdescr,
        lo_elemdescr        TYPE REF TO cl_abap_elemdescr,
        lt_dfies            TYPE ddfields,
        ls_dfies            TYPE dfies,
        lv_sytabix          TYPE sytabix,
        ls_fieldcatalog     TYPE zexcel_s_fieldcatalog,
        lt_components       TYPE abap_component_tab,
        ls_component        LIKE LINE OF lt_components.

  CREATE DATA lr_data LIKE LINE OF ip_table.

  lo_structdescr ?= cl_abap_structdescr=&gt;describe_by_data_ref( lr_data ).

  &quot;for DDIC structure get the info directly
  IF lo_structdescr-&gt;is_ddic_type( ) = abap_true.
    lt_dfies = lo_structdescr-&gt;get_ddic_field_list( ).

    LOOP AT lt_dfies INTO ls_dfies.
      CLEAR ls_fieldcatalog.
      MOVE-CORRESPONDING ls_dfies TO ls_fieldcatalog.
      APPEND ls_fieldcatalog TO ep_fieldcatalog.
    ENDLOOP.
  ELSE.
    &quot;if structure is not DDIC check components
    lt_components = lo_structdescr-&gt;get_components( ).
    LOOP AT lt_components INTO ls_component.
      lv_sytabix = sy-tabix.
      CLEAR ls_fieldcatalog.
      lo_elemdescr ?= ls_component-type.
      &quot;component is DDIC
      IF lo_elemdescr-&gt;is_ddic_type( ) = abap_true.
        ls_dfies = lo_elemdescr-&gt;get_ddic_field( ).
        MOVE-CORRESPONDING ls_dfies TO ls_fieldcatalog.
        ls_fieldcatalog-fieldname = ls_component-name.
      ELSE.
        &quot;component is not DDIC -&gt; return minimum information required
        ls_fieldcatalog-fieldname = ls_component-name.
        ls_fieldcatalog-dynpfld  = abap_true.
        ls_fieldcatalog-scrtext_m = ls_component-name.
      ENDIF.
      ls_fieldcatalog-position = lv_sytabix.
      APPEND ls_fieldcatalog TO ep_fieldcatalog.
    ENDLOOP.
  ENDIF.

endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="NUMBER_TO_EXCEL_STRING" VERSION="1" LANGU="E" DESCRIPT="Converts number to string representation in Excel format" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="NUMBER_TO_EXCEL_STRING" SCONAME="IP_VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="NUMERIC"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="NUMBER_TO_EXCEL_STRING" SCONAME="EP_VALUE" VERSION="1" LANGU="E" DESCRIPT="Cell Value" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEXCEL_CELL_VALUE"/>
  <source>method NUMBER_TO_EXCEL_STRING.
  DATA: lv_value_c TYPE c LENGTH 100.

  WRITE ip_value TO lv_value_c EXPONENT 0 NO-GROUPING NO-SIGN.
  REPLACE ALL OCCURRENCES OF &apos;,&apos; IN lv_value_c WITH &apos;.&apos;.

  ep_value = lv_value_c.
  CONDENSE ep_value.

  IF ip_value &lt; 0.
    CONCATENATE &apos;-&apos; ep_value INTO ep_value.
  ELSEIF ip_value EQ 0.
    ep_value = &apos;0&apos;.
  ENDIF.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="RECURSIVE_CLASS_TO_STRUCT" VERSION="1" LANGU="E" DESCRIPT="Move class to structure" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120316" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="RECURSIVE_CLASS_TO_STRUCT" SCONAME="I_SOURCE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120316" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="RECURSIVE_CLASS_TO_STRUCT" SCONAME="E_TARGET" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120316" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="RECURSIVE_CLASS_TO_STRUCT" SCONAME="E_TARGETX" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120316" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <source>method RECURSIVE_CLASS_TO_STRUCT.
  &quot; # issue 139
* is working for me - but after looking through this coding I guess
* I&apos;ll rewrite this to a version w/o recursion
* This is private an no one using it so far except me, so no need to hurry
  DATA: descr           TYPE REF TO cl_abap_structdescr,
        wa_component    LIKE LINE OF descr-&gt;components,
        attribute_name  TYPE fieldname,
        flag_class      TYPE flag,
        o_border        TYPE REF TO zcl_excel_style_border.

  FIELD-SYMBOLS: &lt;field&gt;      TYPE any,
                 &lt;fieldx&gt;     TYPE any,
                 &lt;class&gt;      TYPE REF TO object,
                 &lt;attribute&gt;  TYPE any.


  descr ?= cl_abap_structdescr=&gt;describe_by_data( e_target ).

  LOOP AT descr-&gt;components INTO wa_component.

* Assign structure and X-structure
    ASSIGN COMPONENT wa_component-name OF STRUCTURE e_target  TO &lt;field&gt;.
    ASSIGN COMPONENT wa_component-name OF STRUCTURE e_targetx TO &lt;fieldx&gt;.
* At least one field in the structure should be marked - otherwise continue with next field
    CLEAR flag_class.
* maybe source is just a structure - try assign component...
    ASSIGN COMPONENT wa_component-name OF STRUCTURE i_source  TO &lt;attribute&gt;.
    IF sy-subrc &lt;&gt; 0.
* not - then it is an attribute of the class - use different assign then
      CONCATENATE &apos;i_source-&gt;&apos; wa_component-name INTO attribute_name.
      ASSIGN (attribute_name) TO &lt;attribute&gt;.
      IF sy-subrc &lt;&gt; 0.
        EXIT.
      ENDIF.  &quot; Should not happen if structure is built properly - otherwise just exit to create no dumps
      flag_class = abap_true.
    ENDIF.

    CASE wa_component-type_kind.
      WHEN cl_abap_structdescr=&gt;typekind_struct1.  &quot; Structure --&gt; use recursio
*        IF flag_class = abap_true.
** Only borders will be passed as unbound references.  But since we want to set a value we have to create an instance
*        ENDIF.
        zcl_excel_common=&gt;recursive_class_to_struct( EXPORTING i_source  = &lt;attribute&gt;
                                                     CHANGING  e_target  = &lt;field&gt;
                                                               e_targetx = &lt;fieldx&gt; ).
      WHEN OTHERS.
        &lt;field&gt; = &lt;attribute&gt;.
        &lt;fieldx&gt; = abap_true.

    ENDCASE.
  ENDLOOP.

endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="RECURSIVE_STRUCT_TO_CLASS" VERSION="1" LANGU="E" DESCRIPT="Move structure to class" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120316" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="RECURSIVE_STRUCT_TO_CLASS" SCONAME="I_SOURCE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120316" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="RECURSIVE_STRUCT_TO_CLASS" SCONAME="I_SOURCEX" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120316" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="RECURSIVE_STRUCT_TO_CLASS" SCONAME="E_TARGET" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20120316" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <source>method RECURSIVE_STRUCT_TO_CLASS.
  &quot; # issue 139
* is working for me - but after looking through this coding I guess
* I&apos;ll rewrite this to a version w/o recursion
* This is private an no one using it so far except me, so no need to hurry
  DATA: descr           TYPE REF TO cl_abap_structdescr,
        wa_component    LIKE LINE OF descr-&gt;components,
        attribute_name  TYPE fieldname,
        flag_class      TYPE flag,
        o_border        TYPE REF TO zcl_excel_style_border.

  FIELD-SYMBOLS: &lt;field&gt;      TYPE any,
                 &lt;fieldx&gt;     TYPE any,
                 &lt;class&gt;      TYPE REF TO object,
                 &lt;attribute&gt;  TYPE any.


  descr ?= cl_abap_structdescr=&gt;describe_by_data( i_source ).

  LOOP AT descr-&gt;components INTO wa_component.

* Assign structure and X-structure
    ASSIGN COMPONENT wa_component-name OF STRUCTURE i_source  TO &lt;field&gt;.
    ASSIGN COMPONENT wa_component-name OF STRUCTURE i_sourcex TO &lt;fieldx&gt;.
* At least one field in the structure should be marked - otherwise continue with next field
    CHECK &lt;fieldx&gt; CA abap_true.
    CLEAR flag_class.
* maybe target is just a structure - try assign component...
    ASSIGN COMPONENT wa_component-name OF STRUCTURE e_target  TO &lt;attribute&gt;.
    IF sy-subrc &lt;&gt; 0.
* not - then it is an attribute of the class - use different assign then
      CONCATENATE &apos;E_TARGET-&gt;&apos; wa_component-name INTO attribute_name.
      ASSIGN (attribute_name) TO &lt;attribute&gt;.
      IF sy-subrc &lt;&gt; 0.EXIT.ENDIF.  &quot; Should not happen if structure is built properly - otherwise just exit to create no dumps
      flag_class = abap_true.
    ENDIF.

    CASE wa_component-type_kind.
      WHEN cl_abap_structdescr=&gt;typekind_struct1.  &quot; Structure --&gt; use recursion
        IF flag_class = abap_true AND &lt;attribute&gt; IS INITIAL.
* Only borders will be passed as unbound references.  But since we want to set a value we have to create an instance
          CREATE OBJECT o_border.
          &lt;attribute&gt; = o_border.
        ENDIF.
        zcl_excel_common=&gt;recursive_struct_to_class( EXPORTING i_source  = &lt;field&gt;
                                                               i_sourcex = &lt;fieldx&gt;
                                                     CHANGING  e_target  = &lt;attribute&gt; ).
      WHEN OTHERS.
        CHECK &lt;fieldx&gt; = abap_true.  &quot; Marked for change
        &lt;attribute&gt; = &lt;field&gt;.

    ENDCASE.
  ENDLOOP.

endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="SHL01" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="15 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="SHL01" SCONAME="I_PWD_HASH" VERSION="1" LANGU="E" DESCRIPT="Password hash" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_PWD_HASH"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="SHL01" SCONAME="R_PWD_HASH" VERSION="1" LANGU="E" DESCRIPT="Password hash" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEXCEL_PWD_HASH"/>
  <source>method SHL01.

  DATA:
     lv_bit TYPE i,
     lv_curr_pos  TYPE i VALUE 2,
     lv_prev_pos TYPE i VALUE 1.

  DO 15 TIMES.
    GET BIT lv_curr_pos OF i_pwd_hash INTO lv_bit.
    SET BIT lv_prev_pos OF r_pwd_hash TO lv_bit.
    ADD 1 TO lv_curr_pos.
    ADD 1 TO lv_prev_pos.
  ENDDO.
  SET BIT 16 OF r_pwd_hash TO 0.

endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="SHR14" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="16 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="SHR14" SCONAME="I_PWD_HASH" VERSION="1" LANGU="E" DESCRIPT="Password hash" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEXCEL_PWD_HASH"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="SHR14" SCONAME="R_PWD_HASH" VERSION="1" LANGU="E" DESCRIPT="Password hash" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEXCEL_PWD_HASH"/>
  <source>method SHR14.

  DATA:
    lv_bit TYPE i,
    lv_curr_pos TYPE i,
    lv_next_pos TYPE i.

  r_pwd_hash = i_pwd_hash.

  DO 14 TIMES.
    lv_curr_pos = 15.
    lv_next_pos = 16.

    DO 15 TIMES.
      GET BIT lv_curr_pos OF r_pwd_hash INTO lv_bit.
      SET BIT lv_next_pos OF r_pwd_hash TO lv_bit.
      SUBTRACT 1 FROM lv_curr_pos.
      SUBTRACT 1 FROM lv_next_pos.
    ENDDO.
    SET BIT 1 OF r_pwd_hash TO 0.
  ENDDO.

endmethod.</source>
 </method>
 <method CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="TIME_TO_EXCEL_STRING" VERSION="1" LANGU="E" DESCRIPT="Convert time from SAP format to Excel" EXPOSURE="2" STATE="1" EDITORDER="17 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="TIME_TO_EXCEL_STRING" SCONAME="IP_VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="T"/>
  <parameter CLSNAME="ZCL_EXCEL_COMMON" CMPNAME="TIME_TO_EXCEL_STRING" SCONAME="EP_VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20111008" CHANGEDBY="DEVELOPER" CHANGEDON="20120317" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEXCEL_CELL_VALUE"/>
  <source>method TIME_TO_EXCEL_STRING.
  DATA: lv_seconds_in_day TYPE i,
        lv_day_fraction TYPE f,
        lc_time_baseline TYPE t VALUE &apos;000000&apos;,
        lc_seconds_in_day TYPE i VALUE 86400.

  lv_seconds_in_day = ip_value - lc_time_baseline.
  lv_day_fraction = lv_seconds_in_day / lc_seconds_in_day.
  ep_value = zcl_excel_common=&gt;number_to_excel_string( ip_value = lv_day_fraction ).
endmethod.</source>
 </method>
</CLAS>
